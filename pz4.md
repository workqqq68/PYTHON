## Практическое занятие №4. Тестирование кода в Python.

### Рассматриваемые вопросы
1. Работа с файлами
2. RAII
3. Статический анализ когда (pylint)
4. Исключения
5. Тестирование
6. Классы

### Работа с файлами
Рассмотрите open и её параметры. Выясните, в чём различие различных режимов открытия файлов.
* 'r'       open for reading (default)
* 'w'       open for writing, truncating the file first
* 'x'       create a new file and open it for writing
* 'a'       open for writing, appending to the end of the file if it exists
* 'b'       binary mode
* 't'       text mode (default)
* '+'       open a disk file for updating (reading and writing)

Пример кода выглядит так:

```python
f = open(filepath, mode)
f.write(str)
str = f.read()
print("Прочитано {0} символов".format(f.tell()))
f.close()
```

Откройте файл по относительному и абсолютному пути. Научитесь писать в файл (f.write) закрывать дескриптор (f.close).

Напишите функцию, которая выводит свой pid (os.getpid), открывает файл /home/an/somefile.txt, засыпает на 1 минуту (time.sleep), пишет в файл некоторую строку, засыпает на 3 минуты. В терминале выполните (PID нужно заменить на тот PID, что выводит ваша программа)

```bash
ls -l /proc/PID/fd
```

Воспользуйтесь оператором with для реализации того же самого. Оператор with реализует концепцию RAII - Resource Acquisition Is Initialization - получение ресурса есть инициализация. Суть концепции в том, что получение некоторого ресурса (в случае with - дескриптора файла) связывается с его инициализацией, а освобождение ресурса связывается с уничтожением объекта. При таком подходе не будет использования неинициализированного дескриптора (вызова f.read тогда, когда f ещё не привязан к файлу), и не будет утечек памяти (когда f.close не вызван).

```python
with open(filepath, mode) as f:
    f.write(str)
    str = f.read()
```

Правильное соединение пути файлов. В Windows и Linux используются разные разделители в пути. В Windows \, в Linux /. Кроме того, существует проблема - пусть в переменной some_path вы храните путь к некоторому файлу или директории. Если это директория, добавление вложенности (т.е. сделать из /home директорию /home/an) требует всё время отслеживать наличие разделителя на конце директории слева. /home и /home/ по разному нужно отрабатывать. А ещё нужно учитывать C:\dir и C:\dir\. Это целый пласт потенциальных проблем, которые решаются простым использованием os.path.join, которая умеет "клеить" пути.

Выполните задания 1 самостоятельной работы.

**Подумайте**, как защитить программу от получения доступа к данным вне каталога пользователя. Представьте, что пользователь ввёл .. - он должен получить доступ к /home/an/.., то есть к /home/. Это частая проблема безопасноти для вебсерверов, когда хитро сформированный путь для загружаемого файла может перезаписать некоторые служебные файлы, например, модули вебсервера.

### Статический анализ кода
Статический анализ кода является одним из инструментов, призванных облегчить процесс разработки программного обеспечения. Статический анализ не устаёт и не подвержен опечаткам, он позволяет удостовериться в хотя бы частичной корректности написанного кода. Для компилируемых языков довольно много статического анализа осуществляет компилятор - как минимум, проверяет типы переменных. Для прошленной разработки компилятору даётся указание "ругаться на всё подряд и не компилировать проект с warning", например, с помощью команды gcc -Wall. Статический анализ призван сократить время, затрачиваемое на поиск ошибок - анализ их выявляет и явно на них указывает. Иногда не совсем по делу, но в целом любые предупреждения компилятора или статического анализатора - это признак того, что code smells.

Используйте pylint <ваш\_файл\_без\_py>. Исправьте код так, чтобы получить 10/10.

Если статический анализ вводится сразу для большого проекта, то слишком низкая оценка не позволяет сразу полноценно использовать статический анализ. Решить эту проблему может принцип "не ухудшения" оценки pylint при рефакторинге или разработке нового кода. То есть никакое изменение не должно ухудшать оценку кода с точки зрения статического анализа.

### Исключения
Общий вид исключений вам уже знаком

```python
try:
    some_func()
except Exception1 as e1:
    some_error_handling1()
except Exception1 as e2:
    some_error_handling2()
finally:
    some_work()
```
Очень плохой практикой является так называемое broad-exception - перехватывание всего подряд, вплоть до базового класса Exception. Причиной тому является то, что some\_error\_handling1 умеет чинить только одну проблему. Обработка ошибок "нет такого файла" или "нет прав на чтения файла" разная. Если файла нет, его может быть уместно создать. Если права неправильные, можно попытаться их исправить, или требуется завершить работу. Резюме: разные ошибки требуют разной обработки.

Код после finally выполняется всегда, возникало ли исключение или нет.

### Тестирование кода в Python
Тесты для калькулятора - unittest. Создайте файл test_pz.py с содержимым (для кода в файле pz.py и функции-калькулятора calc)

```python
import unittest
from pz import calc

class TestCalc(unittest.TestCase):
    def test_calc(self):
        a = 15
        b = 30
        should_ans = 40  # считаем руками, здесь намеренно ошибка
        res = calc(a, b)
        self.assertEqual(res, should_ans)
        
if __name__ == '__main__':
    unittest.main()
```
Запустите тесты

```bash
python3 -m unittest test_pz.py
```

Вы получите ошибку

AssertionError: 45 != 40

где слева - полученное для вашей функции значение, а справа - ожидаемое. Исправьте should_ans так, чтобы получать правильный результат.

Реализуйте в калькуляторе сложение, вычитание, умножение и деление. Проще всего эту задачу свести к известному вам способу со словарём. Обратите внимание, что порядок операндов обратный:

```python
def calc(a, b, op):
    operations = {
        '+' : int.__add__
    }
    op = operations.get(op)
    return op(b, a)
```

С помощью справки **pydoc3 int** выясните, какие операции соответствуют -, / и *. Модифицируйте тесты, покрыв каждую операцию минимум 4 тестами - значения равны, первое значение больше, второе значение больше, одно из значений отрицательное.


### Классы в Python
Класс инкапсулирует данные и методы для работы с этими данными.

В общем случае классы служат для объединения функционала, связанного общей идеей и смыслом, в одну сущность, у которой может быть свое внутреннее состояние, а также методы, которые позволяют модифицировать это состояние. Реальный пример класса: обертка над соединением к базе данных (состояние - постоянное TCP-соединение с базой, методы класса предоставляют интерфейс доступа к соединению). Тем самым TCP соединение инкапсулируется внутри класса, а пользователю класса предоставляем удобный интерфейс доступа к данным.

Типы данных (int, float, ...) и структуры данных (list, dict, ...) - это всё классы.

Для того, что узнать, принадлежит ли объект к определённому типу (т.е. классу), существует стандартная функция isinstance:

```python
num = 13
isinstance(num, int)

numbers = {}
isinstance(numbers, dict)
```
Создадим свой класс с пустым конструктором и одним методом, после чего посмотрим на методы этого объекта - их достаточно много.

```python
class MyClass():
    def __init__(self):
        pass
    def do_some_work(self):
        pass

print(dir(MyClass)
```

### Тестирование с заглушками (Mock)
При тестировании часто возникает ситуация, когда нужно обеспечить поведение некоторой внешней сущности. Например, при тестировании Угадайки необходимо знать число, сгенерированное с помощью random.randint. Если генерация произойдёт внутри Угадайки, то для тестов снаружи это случайное число будет недоступно, как следствие, нельзя будет это значение использовать. Таких внешних сущностей может быть множество - файл или каталог в файловой системе, удалённое соединение с чем-то (например, какой-нибудь API месседжера). В рамках тестов очень ресурсозатратно эмулировать такую внешнюю сущность - зато её можно подменить на контролируемый аналог. Это позволяет протестировать **ваш код** в условиях, когда внешняя сущность ведёт себя ожидаемо. Более того, если ведёт себя неожидаемо тоже - тесты с заглушками могут легко эмулировать ошибки, разрыв соединения, поломанную базу данных и все прочие ошибки, которые непонятно как воспроизвести иным образом.

Реализуйте тесты для угадайки с использованием Mock. Пример замены

```python
from unittest.mock import patch
...
    def testGuesser(self):
        rnd = 15
        with patch('random.randint', return_value=rnd)):
            ugadayka()
```
Необходимо также произвести замену пользовательского ввода на заданное значение из переменной. Код угадайки необходимо переписать так, чтобы можно было по внешнему проявлению понять, было ли число угадано. Например, так:

```python
#!/usr/bin/python3
# это файл pz4.py
import random

class Guesser():
    """Play a 'guess a number' game"""
    def __init__(self):
        """Init a random number for guesser"""
        self.rnd = random.randint(0, 100)
    
    def check(self, guess):
        """Check if guess was right
        Args:
            guess: str from user that guess a number
        
        Returns:
            0 if correct
            1 if guess > self.rnd
            -1 if guess < self.rnd
        
        Raises:
            ValueError: if guess cant be converted to int.
        """
        if guess == self.rnd:
            return 0
        elif guess > self.rnd:
            return 1
        else:
            return -1
        
    def play(self):
        """Start a guess game"""
        while True:
            answer = input('Угадайте число: ')
            # если ввести не число, то всё поломается. Обработку ошибок рассмотрим позже
            answer = int(answer)
    
            # как работает эта конструкция?
            check = self.check(answer)
            if not check:
                print('\nУспех! Верно угадано число {0}'.format(self.rnd))
                break
            elif check == 1:
                print('Бери ниже')
            elif check == -1:
                print('Бери выше')
            else:
                print('Что-то сломалось')
                
if __name__ == '__main__':
    guesser = Guesser()
    guesser.play()
```
Обратите внимание на формат docstring у метода Guesser.check - это принятый в Google codestyle к оформлению docstring. Стандартов оформления документации много, вот выборка из наиболее популярных вариантов приведена ниже. Автор этого курса предпочитает Google-вариант как наиболее наглядный и не загромождённый лишней пунктуацией. 

```python
# reST - reStructuredText, наиболее популярный, рекомендуется PEP 287, формат по умолчанию в PyCharm
"""
This is a reST style.

:param param1: this is a first param
:param param2: this is a second param
:returns: this is a description of what is returned
:raises keyError: raises an exception
"""

# google style
"""
This is an example of Google style.

Args:
    param1: This is the first param.
    param2: This is a second param.

Returns:
    This is a description of what is returned.

Raises:
    KeyError: Raises an exception.
"""

# Epytext - или так называемый javadoc
"""
This is a javadoc style.

@param param1: this is a first param
@param param2: this is a second param
@return: this is a description of what is returned
@raise keyError: raises an exception
"""

# Numpydoc - развитие гугловского формата
"""
My numpydoc description of a kind
of very exhautive numpydoc format docstring.

Parameters
----------
first : array_like
    the 1st param name `first`
second :
    the 2nd param
third : {'value', 'other'}, optional
    the 3rd param, by default 'value'

Returns
-------
string
    a value in a string

Raises
------
KeyError
    when a key error
OtherError
    when an other error
"""

```
Протестируем новую Угадайку

```python
#!/usr/bin/python3
# это файл test_pz4.py
import unittest
from unittest.mock import patch
from pz4 import Guesser

class TestGuesser(unittest.TestCase):
    def test_check(self):
        rnd = 15
        with patch('random.randint', return_value=rnd):
            guesser = Guesser()
        guess = 15
        should_ans = 0
        self.assertEqual(guesser.check(guess), should_ans)
```
Запустим тест

```bash
python3 -m unittest test_pz4.py
```
Воспользуемся модулем nosetests с плагином coverage. Это такая надстройка над unittest в Python, которая предоставляет ряд дополнительных возможностей. Нас интересует измерение покрытия кода тестами. Нужно создать файл .coveragerc с содержимым

```ini
[report]
show_missing = True
```
И запустить тесты.

```bash
# запуск как python -m unittest
nosetests
# запуск с замером покрытия тестов
nosetests --with-coverage
```
В результате вы получите замер покрытия кода для модулей pz4, bootlocale и unittest.mock в районе 1%. Это немного не то, чего мы ожидали, поэтому дополним явное указание модулей, для который измерим покрытие

```bash
nosetests --with-coverage --cover-package=pz4
```
Наконец, честное покрытие. Написано число строк кода (stmts), число не покрытых тестами строк кода (miss), процент покрытия (cover) и строки кода, не покрытые тестами (missing).

Наиболее перспективен следующий шаблон формирования тестов. Для функции func нужно написать три теста:
* test\_func - тестирует func при валидных входных данных.
* test\_func\_wrong - тестирует func при крайних значениях входных данных.
* test\_func\_error - тестирует func при невалидных входных данных, результатом является порождённое исключение.

### Самостоятельная работа
1. Реализуйте программу, которая запрашивает у пользователя путь относительно его домашнего каталога и выполняет для него os.listdir (аналог ls в терминале). То есть при вводе Рабочий стол нужно выводить список содержимого в /home/an/Рабочий\ стол.
2. Расширьте тесты в test\_check так, чтобы весь метод Guesser.check был покрыт тестами. **Подсказка**: guess и should_ans можно сделать списками, а self.assertEqual поместить в обход этих списков.
2. Добавьте метод test\_play в TestGuesser, и с помощью patch подмените input (при патче нужно указывать 'builtins.input') пользователя.
3. Добавьте метод test\_play\_error, который подаёт в input строковое значение, которое не преобразуется в int. Возпользуйтесь self.assertRaises, чтобы убедиться в порождении соответствующего исключения.