## Практическое занятие №1. Введение в Perl и Python

Perl - блестящий язык программирования. Далее подробнее рассмотрим язык программирования Python.

Существует известное выражение: "Python is the second best language for everything". Сильная сторона языка Python - он годится практически для любых задач, выполняя их на четыре с плюсом. Широкая область применения во многом обеспечила популярность Питона.

Создателем Python является Гвидо ван Россум, он же - "великодушный пожизненный диктатор" разработки Python.

Предполагается, что вы уже освоили 2 семестра языков программирования С/С++, 2 семестра ТиМП, java/C# и знакомы с основами работы из командной строки из БОС. Особенности Питона - нет точек с запятой, табуляция определяет вложенность кода, все управляющие конструкции (if, for, while) завершаются двоеточием. Есть множество нюансов со структурами данных, их рассмотрим подробнее позже.

### Рассматриваемые вопросы
1. Немного о Python
2. Запуск интерпретатора Python
3. Модуль random
4. Команда import
5. Работа в IDE PyCharm
6. Класс строка
7. "Магические" методы

### Проба пера - учимся запускать код
Работу нужно вести в виртуальной машине Ubuntu 16.04 v3 (должна располагаться в D:\Виртуалки учебные\Ubuntu 16.04.3 x64 v3, но может и на диске С:). Открываем виртуальную машину, делаем связный клон. Проходим [тестирование остаточных знаний](http://gitlab:5000/python/python).

Откройте терминал (ctrl+t). В командной строке выполните
```bash
python3
```
Знаки <<< означают, что вы находитесь в интерпретаторе Python (вообще говоря, это IDLE - интерактивная оболочка для работы с python, и она сама по себе немало умеет). Выполните

```python
import this
```
И вы увидите Дзен Питона - собрание базовых принципов, которыми стоит руководствоваться при разработке на Питоне. Команда import осуществляет подключение библиотек, this - название стандартной библиотеки питона, которая умеет только выводить текст. Обратим внимание на "explicit is better than implicit" - явное лучше неявного, "simple is better than complex" - простое лучше сложного. В противовес сложным и неочевидным конструкциям других языков программирования (все помнят, что конструкция while ( *(dst++) = *(src++)); копирует src в dst?) Питон предлагает создавать максимально читаемый и простой код.

Посмотрим на другую библиотеку
```python
import random

# вызвать функцию randint из библиотеки random
number = random.randint(0, 100)
number
```
В результате на экране вы получите случайное число от 0 до 100. Как узнать, может ли в результате выпасть крайняя точка 0 или 100? На помощь придёт справка

```python
help(random.randint)
```
Выйти из справки можно, нажав q. Справка доступна и по всей библиотеке help(random) - там сказано, где в интернете найти эту документацию, какие функции, классы и методы библиотеке представляет. Для вызова справки не нужно запускать интерпретатор Python, можно использовать команду pydoc. Выйдите из интерпретатора (набрав exit() или нажав ctrl+d) и выполните

```bash
pydoc random.randint
```

Теперь создадим переменную и исследуем её
```python
a = 5
type(a)
dir(a) # выводит все поля и методы объекта
```
На удивление, наша переменная а с числовым значением оказывается экземпляром объекта с кучей свойств и методов. Все эти свойства можно вызывать. Рассмотрим a.to_bytes

```python
a.to_bytes  # выводит данные про этот метод, включая место (номер) этого объекта в памяти, но не вызывает метод
a.to_bytes() # порождает ошибку
```
С помощью встроенной справки help(a.to_bytes) разберитесь, какие параметры нужно ввести, и добейтесь работоспособности для вариантов Little Endian и Big Endian (строковые названия констант требуются другие).

Оператор = в Python является оператором связывания. На практике довольно многие типы данных в Python являются неизменяемыми (immutable). Так, привычная вам операция инкремента даёт неожиданный результат
```python
id(a)
a += 1
id(a)
```

Использование инкремента не изменило исходный объект. В результате был создан новый объект, и переменная а была связана с новым значением. Рассмотрим второй пример неожиданного поведения:
```python
a = 6
b = 6
c = 1000
d = 1000
id(a)
id(b)
id(c)
id(d)
```

Заметны две особенности. По-первых, почему-то у a и b одинаковые адреса, а у c и d адреса разные. Во-вторых адреса у a и c различаются на много порядков. Ответ кроется в оптимизациях, используемых интерпретатором. Разработчиками Python было замечено, что наиболее часто в программах используются числа от -5 до 256. Весь этот диапазон чисел создаётся при старте интерпретатора, и новые переменные из этого диапазона только связываются с заранее созданными объектами. Теперь попробует дальше
```python
c = 1000; d = 1000
```

Снова неожиданный результат. Если переменные созданы на одной строке (или в запущенном файле "достаточно близко"), то интерпретатор способен такую ситуацию отследить, и создать один объект, и связать с ним две переменные.

Одним из приятных свойств Python являются удобные способы задания условий. Попробуем
```python
a = 5
0 <= a <= 10
```

Такая интуитивно понятная форма записи работает. Вернёмся к связыванию и использованию dir:
```python
a = 5
dir(a)
a = this
dir(a)
dir(this)
```
В переменную можно поместить даже импортированный ранее модуль. Кроме того, для модуля можно получить список его полей и методов.

### PyCharm
Перейдём к IDE PyCharm от JetBrains. Создайте в PyCharm проект pz1. Это занимает длительное время из-за создания виртуального окружения, которое мы рассмотрим позже.

В проекте создайте файл printer.py с содержимым 
```python
print('hello world')
a = 15

```
Если в созданном файле не получается что-либо написать, то проверьте нижнюю строку. Если там написано Vim recording или что-то подобное, то вы включили режим эмуляции редактора VIM. Выключить его можно через Tools - Vim Emulator.

Нажмите View - Tools Button. Затем включите View - Tools window - Python Console, затем View - Tools window - Terminal (alt+F12). В результате внизу окна будут доступны вкладки python console с интерпретатором Питона (далее **консоль**) и terminal с интерпретатором командной строки bash (далее **терминал**). Вообще консоль и терминал - синонимы, но писать каждый раз консоль питона длиннее. Для взаимодействия с разработанным кодом можно использовать и консоль, и терминал на ваш выбор. Отдельно терминал будет использоваться для работы с системой контроля версий git. Существует возможность запуска нескольких вкладок терминала, если так будет удобнее.

Рассмотрим, как можно взаимодействовать с нашими двумя строчками кода из консоли. В консоли выполните import printer - получите строку hello world на экран. Доступ к переменной a можно получить с помощью printer.a. Если на месте а будет длинная и часто используемая переменная, то можно выполнить

```python
from printer import a
```
И далее использовать a. Измените в коде printer.py значение a на 20. Заметьте, что в консоли внизу значение а не изменилось. При этом IDE автоматически сохранила изменённый файл. Чтобы в консоли появилась новая версия нашего кода, нужно нажать пиктограмку слева-сверху в консоли - rerun (ctrl+F5), после чего повторно выполнить импорт.

Рассмотрим, как можно взаимодействовать с нашими двумя строчками кода из терминала. Во вкладке терминала выполните python3 -i printer.py. В результате вы окажетесь внутри интерпретатора Питона, при этом вызов a выведет на экран её значение. То есть import как бы выполнен за нас флагом -i у команды python. Выйти из интерпретатора - exit() или ctrl+d. Измените в коде printer.py значение a на 200. Кнопной вверх можно снова получить запуск интерпретатора.

Использовать можно любой из способов.

### Модули в python
Почему для import this и import printer мы получаем на экран некоторый вывод, а import random происходит молча? Какой способ более правильный? Внимательный читатель заметит, что вывод на экран - это некоторый побочный результат (side effect). К side effect относят также запись в файл или порождение исключений. Представьте, что вы подключаете библиотеку, а она создаёт какие-то файлы. Вряд ли это можно считать корректным поведением.

Допишите в код строку 
```python
print(__name__)
```

Запустите код с помощью Run - run. В выводе вы увидите \_\_main\_\_. Теперь выполните import printer в консоли питона - вместо main теперь на экране printer. Переменная \_\_name\_\_ позволяет узнать, как был запущен код - в виде самостоятельно исполняемого файла (там будет \_\_main\_\_) или в виде библиотеки (там будет название модуля). Этот факт позволяет добавить такую проверку:

```python
a = 15

if __name__ == '__main__':
    print('hello world')
```
Теперь запущенный явно код выводит на экран надпись, а импорт этого кода в качестве библиотеки ничего не делает. Переменная а объявлена до проверки, поэтому она будет доступна в любом из вариантов запуска. Хорошем стилем разработки является создание функции main(), которая делает то, что нужно. А основной код выглядит так:

```python
if __name__ == '__main__':
    main()
```
Модуль в Питон - это обычный файл с расширением .py. Модули могут быть объединены в пакет - каталог, где есть несколько модулей.
### Угадайка
Реализуйте такую функцию main
```python
# все импорты должны быть в начале файла
import random

def main():
    """Угадайка"""
    number = random.randint(0, 100)
    while True:
        answer = input('Угадайте число: ')
        # если ввести не число, то всё поломается. Обработку ошибок рассмотрим позже
        answer = int(answer)
    
        if answer == number:
            print('Успех')
            break
        
        elif answer < number:
            print('Бери выше')
        else:
            print('Бери ниже')
```
Запустите этот код и укадайте число.
### Класс "строка"
Рассмотрим подробнее класс "строка" в Питоне. Он, как и практически всё в Питоне, представлен объектом со множеством методов. Выполните в консоли

```python
answer = input()
# здесь введите что-нибудь
answer
type(answer)
```
Питон предоставляет простой способ изучения объектов "изнутри". Для этого нужно вызвать команду dir для любого объекта. Применим её к результату нашего пользовательского ввода answer из примера выше.

```python
dir(answer)
```
Вы получите длинную строку с результатом. В иконках слева найдите "soft wraps" - эта настройка отвечает за разбиение длинного вывода на множество строк. Без soft wraps длинная строка "уедет" вправо и появится горизонтальный скролл.

Рассмотрим полученный вывод. Каждое слово в нём - это метод, который вы можете вызвать у вашего экземпляра answer класса строка. В нём присутствуют множество "магических методов" (magic methods), которые начинаются и заканчиваются с двойного нижнего подчёркивания. Особенность "магических" методов в том, что они вызываются косвенным образом, а не напрямую - хотя возможность прямого вызова существует. Рассмотрим метод \_\_class\_\_

```python
answer.__class__
```
Получаемый вывод аналогичен выводу type(answer), что наводит на мысль: хитрый Питон хранит информацию о классе в нём самом. И функция type возвращает эту информацию. Не нужно явно вызывать "магические" методы, для их вызова есть более приятные и понятные конструкции.

Отложим на некоторое время магические методы и вернёмся к методам обычным. Найдите в выводе dir(answer) метод isdigit. Он довольно говорящий - позволяет узнать, является ли строка числом.

```python
answer.isalpha()
```
Применять метод isalpha можно к любому экземпляру класса строка, в том числе к константам.

```python
'123'.isalpha()
'сто двадцать три'.isalpha()
```
Для всех методов есть справка, которая вызывается help(str.isalpha). Следующий важный метод str.upper, который возвращает копию заданной строки, приведённой к верхнему регистру. Строки в Питон - вообще неизменяемый тип данных. Нет возможности изменить часть исходной строки, можно лишь создать новую строку на основе существующей. Воспользуемся функций id, которая возращает уникальный идентификатор объекта. Попробуем перевести наш пользовательский ответ в верхний регистр, проследив идентификатор нашего ответа.
```python
id(answer)
answer = answer.upper()
id(answer)
```
Как видно из вывода, мы просто имеем новую строку с другим идентификатором.

### Задание
Доработайте Угадайку так, чтобы при вводе нечислового значения об этом выводилось сообщение и предлагался повторный ввод. Завершать работу с сообщением-выводом правильного числа, если введено exit.