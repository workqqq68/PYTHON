## Практическое занятие №5. Работа с классами в Python

### Рассматриваемые вопросы
1. Классы
2. Итераторы
3. Контекстные менеджеры

### Классы в Python, продолжение
Предположим, что наш класс описывает планету (причём любую, абстрактную планету). Экземплярами класса будут являться конкретные планеты - Земля, Марс и т.д. Для того, чтобы создать экземпляр класса, обращаются к имени класса с помощью (): 
```python
class Planet: 
    pass 

planet = Planet()
print(planet)
```
Мы получили не просто класс, а объект этого класса. Но ничто не мешает нам оперировать с классами как с объектами, так как всё в Python есть объект. Давайте с помощью небольшого скрипта промоделируем создание Солнечной системы: 

```python
solar_system = [] 
for i in range(8): 
    planet = Planet() 
    solar_system.append(planet) 

print(solar_system) 
```
Важно отметить, что экземпляры класса - это хэшируемые объекты (могут быть ключами словаря). Например, исправим предыдущий пример так, чтобы экземпляры класса Planet стали ключами словаря: 

```python
solar_system = {} 
for i in range(8): 
    planet = Planet() 
    solar_system[planet] = True 

print(solar_system) 
```
Чтобы назвать планеты нашей Солнечной системы, мы будем использовать один из магических методов класса --- метод __init__. Этот метод вызывается автоматически при создании экземпляра класса. Первым аргументом метод __init__ принимает ссылку на только что созданный экземпляр класса, далее могут идти другие аргументы. Внутри инициализатора мы можем по ссылке self установить так называемые атрибуты экземпляра. В данном случае мы ставим атрибут экземпляра name и присваиваем ему аргумент name - имя планеты. Мы можем обратиться к атрибуту класса, написав его через точку после названия экземпляра: 

```python
class Planet: 
    def __init__(self, name): 
        self.name = name 

earth = Planet("Earth") 
print(earth.name) 
print(earth) 
```
Можно сделать так, чтобы print(earth) печатал имя планеты. Для этого есть магический метод \_\_str\_\_, позволяющий переопределить то, как будет печататься объект: 

```python
class Planet: 
    def __init__(self, name): 
        self.name = name 

    def __str__(self): 
        return self.name 

earth = Planet("Earth") 
print(earth) 
```
Давайте назовём все планеты солнечной системы: 

```python
solar_system = [] 
planet_names = [ 
    "Mercury", "Venus", "Earth", "Mars", 
    "Jupiter", "Saturn", "Uranus", "Neptune" 
]

for name in planet_names: 
    planet = Planet(name) 
    solar_system.append(planet) 

print(solar_system) 
```
Несмотря на то, что мы переопределили метод \_\_str\_\_, внутри списка мы видим объекты в старом представлении. Чтобы отображать объекты в списке, Python использует другой магический метод - \_\_repr\_\_, который мы тоже можем переопределить: 

```python
class Planet: 
    def __init__(self, name): 
        self.name = name 

    def __repr__(self): 
        return "Planet {0}".format(self.name)

solar_system = [] 
planet_names = [ 
    "Mercury", "Venus", "Earth", "Mars", 
    "Jupiter", "Saturn", "Uranus", "Neptune" 
]

for name in planet_names: 
    planet = Planet(name) 
    solar_system.append(planet) 

print(solar_system) 
```
Существует огромное множество других магических методов классов, про некоторые из которых мы поговорим позже. 

Есть возможность в любой момент поменять значение атрибута класса. Если обратиться к несуществующему атрибуту экземпляра, Python выдаст исключение AttributeError. 
```python
mars = Planet("Mars") 
print(mars) 
print(mars.name)
mars.name = "Second Earth?" 
print(mars.name)
print(mars.mass)  # AttributeError
```
Кроме того, мы можем удалить атрибут из нашего экземпляра класса: 
```python
del mars.name 
print(mars.name)
```
Иногда нужно создать переменную, которая будет работать в контексте класса, но не будет связана с каждым конкретным экземпляром (т.е. будет относиться непосредственно к самому классу, а не к экземпляру). В этом примере count (счётчик планет) - это атрибут класса: 

```python
class Planet: 

    count = 0 

    def __init__(self, name, population=None): 
    self.name = name 
    self.population = population or [] 
    Planet.count += 1 

# Можем напрямую обратиться к атрибуту класса через точку: 
earth = Planet("Earth") 
mars = Planet("Mars") 

print(Planet.count) 
```
Открыть словарь с атрибутами класса можно с помощь \_\_dict\_\_. Там появляются все добавляемые атрибуты.

```python
earth.__dict__
earth

earth.mass = 5.97e24
earth.__dict__
```
Словарь атрибутов есть также и у самого класса (обратите внимание на атрибуты \_\_doc\_\_ и count): 

```python
Planet.__dict__ 
```
К элементам из словаря атрибутов класса можно обращаться как через имя класса, так и через имя какого-нибудь экземпляра этого класса: 

```python
Planet.__doc__ 
earth.__doc__
```
У экземпляра класса есть ещё много магических методов (например, метод \_\_hash\_\_, ведь экземпляры класса - это хэшируемые объекты). 

```python
print(dir(planet))
```
В любой момент мы можем узнать, какому классу принадлежит данный экземпляр: 

```python
planet.__class__ 
```
Конструктор экземпляра класса позволяет нам переопределить действия, которые происходят с экземпляром до его инициализации. На следующих неделях будет показан пример использования магического метода __new__, который как раз является конструктором экземпляра класса, в рамках использования метаклассов. Пока же посмотрим на простой пример класса с переопределённым методом \_\_new\_\_: 

```python
class Planet: 

    def __new__(cls, *args, **kwargs): 
        print("__new__ called") 
        obj = super().__new__(cls) 
        return obj 

    def __init__(self, name): 
        print("__init__ called") 
        self.name = name 

earth = Planet("Earth") 
```
В этом примере в исходный метод \_\_new\_\_ был добавлен вызов print(). В следующей строке метод super() возвращает родителя нашего класса, в данном случае это object - класс, от которого наследуются все пользовательские классы в Python 3. Затем вызывается метод \_\_new\_\_ класса object, который возвращает экземляр класса. Этот экземпляр (который и является нашим классом) возвращается из функции. 

То есть при вызове Planet("Earth") произошло примерно следующее: 

```python
planet = Planet.__new__(Planet, "Earth") 

if isinstance(planet, Planet):  # если __new__ вернул правильный класс 
    Planet.__init__(planet, "Earth") 
```
### Методы
Методы - это функции, которые действуют в контексте экземпляра класса. Таким образом, они могут менять состояние экземпляра, обращаясь к атрибутам экземпляра или делать любую другую полезную работу. В следующем примере мы создали класс human, у которого есть два атрибута: name и age, а также у нас есть класс планеты, у которой есть атрибут name и атрибут population (список людей, которые есть на планете): 

```python
class Human: 

    def __init__(self, name, age=0): 
        self.name = name 
        self.age = age 


class Planet: 

    def __init__(self, name, population=None): 
        self.name = name 
        self.population = population or [] 

    def add_human(self, human): 
        print("Welcome to {1}, {2}!".format(self.name, human.name) 
        self.population.append(human) 
```
Здесь мы объявили метод экземпляра add human - просто функцию, которая принимает первым аргументом self (т.е. ссылку на экземпляр класса), а дальше - любые другие аргументы (в случае выше это экземпляр класса Human). Обновим население планеты: 

```python
mars = Planet("Mars") 
bob = Human("Bob") 
mars.add_human(bob) 
```
Ничто не мешает вызывать из методов другие методы. Ниже объявляем класс Human, у которого названия атрибутов \_name и \_age начинаются с символа нижнего подчёркивания. Также у этого класса метод экземпляра \_say, который также начинается с нижнего подчёркивания, а ещё два метода say\_name и say\_how\_old, которые печатают, сколько человеку лет и какое у него имя. Символы нижнего подчёркивания показывают, что это внутренний метод, который вызывается только другими методами класса, но не должен вызываться пользователем. Такой механизм похож на private/protected атрибуты в других языках, однако в Python это всего лишь соглашение. Тем не менее, если атрибут либо метод названы c символа нижнего подчёркивания, то ими пользоваться не рекомендуется потому, что в дальнейших версиях той или иной библиотеки могут отказаться от этих атрибутов или методов, начинающихся с символа нижнего подчеркивания, либо поменять их поведение. 

```python
class Human: 

    def __init__(self, name, age=0): 
        self._name = name 
        self._age = age 

    def _say(self, text): 
        print(text) 
        def say_name(self): 
        self._say(f"Hello, I am {self._name}") 

    def say_how_old(self): 
        self._say(f"I am {self._age} years old") 


bob = Human("Bob", age=29) 
bob.say_name() 
bob.say_how_old() 

# не рекомендуется! обратите внимание на реакцию pylint на такой код
print(bob._name) 

# не рекомендуется! 
bob._say("Whatever we want") 
```
Бывает, что вам нужно объявить метод, который не привязан к конкретному экземпляру, но в тоже время вовлекает в свою работу сам класс. Для этого существует стандартный декоратор \@classmethod (метод класса). Декораторы мы рассмотрим позже. Например, создадим класс, который отображает какое-нибудь событие: 

```python
class Event: 

    def __init__(self, description, event_date): 
    self.description = description 
    self.date = event_date 

    def __str__(self): 
    return "Event \"{1}\" at {2}".format(self.description, self.date)

from datetime import date 
event_description = "Рассказать, что такое @classmethod" 
event_date = date.today() 
event = Event(event_description, event_date) 
print(event)
```
Дополним этот класс методом класса. Метод from_string извлекает из пользовательского ввода информацию о некотором событии (например, такой метод может быть полезен при написании бота для мессенджера, который заносит события в календарь). Этот метод принимает на вход первым атрибутом сам класс cls, а затем ввод пользователя. Он возвращает экземпляр класса, таким образом, это альтернативный способ создания класса. 

```python
# добавить внутрь класса Event
    @classmethod 
    def from_string(cls, user_input): 
        description = extract_description(user_input) 
        date = extract_date(user_input) 
        return cls(description, date) 
```
Вообще, извлечение данных из сообщений - это сложная задача. В нашем примере мы используем заглушки и попробуем

```python
def extract_description(user_string): 
    return "открытие чемпионата мира по футболу" 

def extract_date(user_string): 
    return date(2018, 6, 14) 

event = Event.from_string("добавить в мой календарь открытие чемпионата мира по футболу на 14 июня 2018 года") 
print(event) 
```
Внутри стандартной библиотеки класс-методы тоже активно используются. Например, тип dict - это класс, у которого есть метод fromkeys.fromkeys - как раз метод класса, который принимает итерабельный объект и возвращает проинициализированный словарь: 

```python
dict.fromkeys("12345") 
```
### Итераторы
Пример работы с итераторами - использование функции range для цикла for. Цикл for позволяет пробегать по итератору и, например, выводить подряд числа, как в случае с функцией range: 

```python
for number in range(5): 
    print(i)
```
Также простейшим итератором является строка или коллекция:

```python
for letter in 'python': 
    print(ord(letter)) 
```
Итератор — это объект, по которому вы можете "пробегаться" или итерироваться. Можно создать свой простейший итератор при помощи встроенной функции iter() и, например, передать ей список. Внутри протокол итерации работает очень просто. Для получения следующего элемента каждый раз вызывается функция next(), которая возвращает следующий элемент. В данном случае это 1, 2 и 3. Когда элементы исчерпаны, то есть итератор закончился, выбрасывается исключение StopIteration, которое говорит о том, что, например, нужно выйти из цикла for: 

```python
iterator = iter([1, 2, 3]) 
print(next(iterator)) 
print(next(iterator)) 
print(next(iterator)) 
print(next(iterator)) 
```
В Python-е вы, конечно, можете реализовать свой собственный итератор, написав класс с соответствующими магическими методами. Эти магические методы — это методы \_\_iter\_\_ и \_\_next\_\_. Метод \_\_iter\_\_ должен возвращать сам итератор, а метод \_\_next\_\_ определяет то, какие элементы возвращаются при каждой следующей итерации. Давайте напишем свой класс SquareIterator, который будет аналогом функции range, но возвращающим не сами числа в определённом диапазоне, а квадраты чисел. В функции \_\_init\_\_ сохраняются пределы итерирования, а в функции \_\_next\_\_ указано, что происходит при вызове следующего элемента. Если элементы исчерпаны (current превысил end), выбрасываем исключение StopIteration, которое говорит протоколу итерации о том, что итерация должна закончиться. В любом другом случае мы возводим чис- 
ло в квадрат и инкрементируем счётчик: 

```python
class SquareIterator: 
    def __init__(self, start, end): 
        self.current = start 
        self.end = end 

    def __iter__(self): 
        return self 

    def __next__(self): 
        if self.current >= self.end: 
        raise StopIteration
        
        result = self.current ** 2 
        self.current += 1 
        return result 

for num in SquareIterator(1, 4): 
    print(num) 
```

### Контекстные менеджеры
С контекстными менеджерами вы уже работали, когда открывали файлы. Вам известно, что если использовать контекстный менеджер with для открытия файла, вам не нужно заботиться о том, чтобы потом его закрыть — контекстный менеджер сделает это сам. 

Контекстные менеджеры определяют поведение, которое происходит в начале и в конце блока исполнения (блока with). Часто после использования ресурса его необходимо закрыть (как, например, в случае с файлами, сокетами, соединениями). Чтобы об этом не заботиться, можно использовать контекстный менеджер. Также они используются при работе с транзакциями (когда обязательно нужно либо закончить транзакцию, либо ее откатить). 

Чтобы определить свой контекстный менеджер, нужно написать свой класс с магическими методами. Эти магические методы — \_\_enter\_\_ и \_\_exit\_\_, которые говорят о том, что происходит в начале и в конце исполнения кода внутри контекстного менеджера. 

Давайте попробуем написать аналог стандартного контекстного менеджера для открытия файлов и назовём его open_file. (Обратите внимание, что название класса пишется snake_case-ом, так как это контекстный менеджер.) 
```python
with open('access_log.log', 'a') as f: 
	f.write('New Access') 
```
Итак, наш контекстный менеджер используется точно так же, как и стандартный. При вызове open\_file создается файловый объект (вызывается метод \_\_init\_\_), который записывается в переменную класса f. Переменная f возвращается из метода \_\_enter\_\_ (метод \_\_enter\_\_ возвращает то, что требуется потом записать с помощью оператора as — мы можем ничего не возвращать из \_\_enter\_\_, но тогда не будет смысла использовать as). Соответственно, в методе \_\_exit\_\_ определяется поведение, которое происходит при выходе из блока контекстного менеджера: 

```python
class open_file: 
    def __init__(self, filename, mode): 
        self.f = open(filename, mode) 

    def __enter__(self): 
        return self.f 

    def __exit__(self, *args): 
        self.f.close() 

with open_file('test.log', 'w') as f: 
    f.write('Inside `open_file` context manager') 

with open_file('test.log', 'r') as f: 
    print(f.readlines()) 
```
Итак, мы открыли файл и записали в него строчку. Если попробовать прочитать этот файл, окажется, что строчка действительно там, а файл открылся и закрылся сам. Контекстные менеджеры позволяют управлять исключениями, которые произошли внутри блока. Например, мы можем определить контекстный менеджер suppress\_exception, который будет работать с exception-ами, которые произошли внутри. Обратите внимание, что в данном случае мы не используем оператор as, поэтому нам не важно, что возвращается из \_\_enter\_\_. Пусть наш контекстный менеджер будет принимать тип exception-а и затем проверять, произошло ли исключение данного типа. Если да — делаем вид, что ничего не произошло. (Нужно обязательно вернуть true из \_\_exit\_\_ при исключении, чтобы воспроизведение кода продолжилось и exception не был выброшен.) 

```python
class suppress_exception: 
    def __init__(self, exc_type): 
        self.exc_type = exc_type 

    def __enter__(self): 
        return 
    
    def __exit__(self, exc_type, exc_value, traceback): 
        if exc_type == self.exc_type: 
            print('Nothing happend.') 
            return True 

with suppress_exception(ZeroDivisionError): 
    really_big_number = 1 / 0 
```
Что интересно, такой контекстный менеджер уже есть в стандартной библиотеке в contextlib: 

```python
import contextlib 
with contextlib.suppress(ValueError): 
    raise ValueError 
```
В качестве примера реализуем контекстный менеджер, который считает время, за которое выполняется код внутри него. Для этого нужно завести переменную, которая фиксирует время запуска контекстного менеждера. Происходит это в методе \_\_init\_\_, когда создается объект класса. В \_\_exit\_\_ вернём разность текущего времени и сохранённого в методе \_\_init\_\_. Также, чтобы иметь возможность выводить внутри контекстного менеджера текущее время выполнения, пропишем return self в \_\_enter\_\_ и определим метод класса current_time: 

```python
import time 

class timer(): 
    def __init__(self): 
        self.start = time.time() 

    def current_time(self): 
        return time.time() - self.start 

    def __enter__(self): 
        return self 

    def __exit__(self, *args): 
        print('Elapsed: {}'.format(self.current_time())) 

with timer() as t: 
    time.sleep(1) 
    print('Current: {}'.format(t.current_time())) 
    time.sleep(1) 
```

### Самостоятельная работа
1. Создание класса фигура и классов-наследников круг, квадрат, овал. Метод draw должен в текстовом виде нарисовать указанные фигуры. Переопределить метод \_\_str\_\_ для получения названия фигуры (например, "Круг"). Переопределите \_\_repr\_\_ на получение названия фигуры, но визуально отличающееся от названия в str (например, "Фигура Круг"). Продемонстрируйте результат работы этих двух магических методов.
2. Реализация классов ReaderJson и ReaderXml для чтения данных в форматах json и xml с использованием наследования от класса Reader. Реализация собственного итератора для класса ReaderInh (Inh == Inheritance, наследование). Дополнить метод draw опциональным параметром размер (трактовать как радиус круга, сторону квадрата, ширину овала - длину устанавливать втрое больше ширины).