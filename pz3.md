## Практическое занятие №3. Структуры данных . Кортежи, списки, словари, множества

### Рассматриваемые вопросы
1. Списки
2. Кортежи
3. Словари
4. Множества

Во время работы пользоваться системой контроля версий. Краткий мануал [в вики](http://gitlabnto/anetto/wiki/wikis/gitlab-ssh). Каждые 3-5 строк кода должны входить в очередной коммит в git. Весь проработанный материал должен быть добавлен в личный репозиторий и запушен на gitlabnto.

### Списки
Коллекция - это переменная-контейнер, в которой может содержаться какое-то количество объектов, где объекты могут быть одного типа или разного. В случае списков это упорядоченные наборы элементов, которые могут быть разных типов. Сами списки определяются с помощью квадратных скобочек или с помощью вызова литерала list. Вы также можете создать список из одинаковых значений с помощью умножения. Несмотря на вышесказанное, чаще всего списки содержат переменные одного типа. Также списки могут содержать другие коллекции.

```python
empty_list = [] 
empty_list = list() 
none_list = [None] * 10 
collections = ['list', 'tuple', 'dict', 'set'] 
user_data = [ 
['Elena', 4.4], 
['Andrey', 4.2] 
] 
```

Для получения длины списка вызывают встроенную функцию len(). В Python не нужно явно указывать размер списка или вручную выделять на него память. Размер списка хранится в структуре, с помощью которой реализован тип список, поэтому длина вычисляется за константное время. При этом вспомним dir. В выводе dir найдите "магический" метод определения размера списка.

```python
len(collections)
dir(collections)
collections.__len__()  # эквивалентно len(collections), но куда изящнее
```
Чтобы обратиться к конкретному элементу списка, мы используем тот же механизм, что и для строк - обращаемся к элементу по индексу. Нумерация элементов начинается с нуля. Отрицательные элементы всё также значат "с конца". 

```python
print(collections) 
print(collections[0]) 
print(collections[-1]) 
```

Допускаются присваивания по индексу.

```python
collections[3] = 'frozenset'
```

Обращение к несуществующему индексу приводит к ошибке IndexError: list index out of range. 
```python
collections[20]  # порождается исключение
```

С помощью оператора in можно проверить, существует ли какой-то объект в списке: 

```python
'tuple' in collections 
```
Срезы в списках работают точно так же, как и в строках. Создадим список из 10 элементов с помощью встроенной функции range и поэкспериментируем на нём со срезами:

```python
range_list = list(range(10)) 
print(range_list) 
range_list[1:3] 
range_list[::2] 
range_list[::-1] 
range_list[5:1:-1] 
```
Важно знать, что при получении среза создаётся новый объект - новый список:

```python
range_list[:] is range_list  # возвращает False
```
Как и все коллекции, списки поддерживают итерирование. Обратите внимание, что итерация производится именно по элементам списка, а не по индексам, как во многих других языках. 

```python
collections = ['list', 'tuple', 'dict', 'set'] 
for collection in collections: 
    print('Learning {0}...'.format(collection))
```
Часто бывает нужно получить индекс текущего элемента при итерации. Для этого можно использовать встроенную функцию enumerate, которая возвращает индекс и текущий элемент. 

```python
for idx, collection in enumerate(collections): 
    print('#{0} {1}'.format(idx, collection))
```
Так как списки являются изменяемой структурой данных, мы можем добавлять и удалять элементы. Например, мы можем добавить в наш список collections элемент 'OrderedDict'. 

```python
collections.append('OrderedDict') 
print(collections) 
```
Если вам нужно расширить список другим списком, вы можете использовать метод extend, который добавляет переданный список в конец вашего списка. 

```python
collections.extend(['ponyset', 'unicorndict']) 
print(collections) 
```
Также можно использовать перегруженный оператор +, который также добавляет переменную в конец вашего списка: 

```python
collections += [None] 
print(collections)
```
Для удаление элемента из списка можно использовать ключевое слово del. 

```python
del collections[4] 
print(collections)
```
Часто нам нужно найти минимальный/максимальный элемент в массиве или посчитать сумму всех элементов. Вы можете это сделать при помощи встроенных функций min, max, sum. Не забывайте, что это всё "магические" методы.

```python
numbers = [4, 17, 19, 9, 2, 6, 10, 13] 
print(min(numbers)) 
print(max(numbers)) 
print(sum(numbers)) 
```
Часто бывает полезно преобразовать список в строку, для этого можно использовать идиому str.join(): 

```python
tag_list = ['python', 'course', 'coursera'] 
print(', '.join(tag_list))
```
Ещё одна часто встречающаяся операция со списками - это сортировка. В Python существует несколько методов сортировки. Для начала создадим случайный список с помощью функции модуля random. Переменную для итерации называли _, т.к. сама эта переменная не используется.

```python
import random 
numbers = [] 
for _ in range(10):
    numbers.append(random.randint(1, 20)) 
print(numbers)
```
Для сортировки списка в Python есть два способа: стандартная функция sorted, которая возвращает новый список, полученный сортировкой исходного, и метод списка .sort(), который сортирует in-place. Для сортировки используется алгоритм TimSort. 

```python
print(sorted(numbers)) 
print(numbers)

numbers.sort() 
print(numbers)
```
Если нужно отсортировать список в обратном порядке:

```python
print(sorted(numbers, reverse=True)) 
numbers.sort(reverse=True) 
print(numbers) 
```
Для той же цели можно использовать встроенную функцию reversed, которая возвращает так называемый reverse iterator. Об итераторах будет сказано позднее, пока достаточно понимать, что это объект, который поддерживает протокол итерации. Данный объект можно преобразовать в список, и получится список с обратным порядком элементов. 

Кроме методов, которые мы обсудили выше, существует также много других, о которых 
можно прочесть в документации: 
* append 
* clear 
* copy 
* count 
* extend 
* index 
* insert 
* pop 
* remove 
* reverse 
* sort 

### Кортежи 
Кортежи - это неизменяемые списки (мы не можем ни добавлять, ни удалять элементы из кортежа). Кортежи определяются с помощью круглых скобок или литерала tuple. 

```python
empty_tuple = () 
empty_tuple = tuple() 
```
Например, мы можем создать кортеж immutables и поместить туда неизменяемые типы. 

```python
immutables = (int, str, tuple) 
```
Если попробовать заменить нулевой элемент на float, Python выдаст исключение TypeError, потому что кортежи неизменяемы. 

```python
immutables[0] = float  # порождается исключение
```
Но несмотря на то, что сами кортежи неизменяемые, объекты внутри них могут быть изменяемыми. Например, если кортеж содержит список, мы можем добавлять элементы в этот список. 

```python
blink = ([], []) 
blink[0].append(0) 
print(blink) 
```
Важная особенность кортежей - к ним применяется функция hash, и поэтому они могут использоваться в качестве ключей в словарях, о которых мы поговорим позднее. 

```python
hash(tuple())
```
Будьте внимательны при определении кортежа из одного элемента - не забывайте писать запятую. Если вы забудете про нее, Python сочтет вашу переменную типом int. 

```python
one_element_tuple = (1,) 
guess_what = (1) 
type(guess_what)
```

### Списки. Пример программы
Разберём задачу на применение списков - поиск медианы случайного списка. Медиана - это значение в отсортированном списке, которое лежит ровно посередине, таким образом, половина значений --- слева от него, и половина значений - справа. 
Сначала создадим случайный список со случайным (чтобы было интереснее) количеством элементов. Функция randint возвращает случайное целое число в переданном ей интервале

```python
import random 
numbers = [] 
numbers_size = random.randint(10, 15) 
for _ in range(numbers_size): 
	numbers.append(random.randint(10, 20)) 
print(numbers) 
```
Отсортируем наш список: 

```python
numbers.sort() 
```
По определению медианы, она равна среднему элементу в отсортированном списке, если количество элементов нечётное. Если число элементов чётное, то медиана - это среднее арифметическое от двух средних элементов. Мы заведем переменную half_size, в которую положим значение, равное половине длины списка. Также заведём переменную median, сначала имеющую значение None. Запишем условие на чётность элементов и найдём медиану по определению для каждого случая

```python
numbers.sort() 
half_size = len(numbers) // 2 
median = None 
if numbers_size % 2 == 1: 
	median = numbers[half_size] 
else:
	median = sum(numbers[half_size - 1:half_size + 1]) / 2 
print(median) 
```
Чтобы проверить наш результат, можно воспользоваться встроенным модулем statistics. 

```python
import statistics 
statistics.median(numbers) 
```
Для обхода одновременно двух списков одинакового размера существует устойчивая идиома

```python
colors = ['white', 'blue', 'red']
worms = ['Ivan', 'Petr', 'Stepan']
for color, worm in zip(colors, worms):
    print('Worm {0} is colored in {1} ink'.format(worm, color))
```
### Словари
Словари являются важнейшей структурой данных в Python. Они позволяют хранить данные в формате ключ-значение. Чтобы определить словарь, нужно использовать литерал фигурные скобки или просто вызвать dict. Если мы хотим, определяя словарь, сразу добавить в него данные, пишем ключ-значение через двоеточие. 

```python
empty_dict = {} 
empty_dict = dict() 
collections_map = { 
    'mutable': ['list', 'set', 'dict'], 
    'immutable': ['tuple', 'frozenset'] 
} 
```
Доступ к значению по ключу осуществляется за константное время, то есть не зависит от размера словаря. Это достигается с помощью алгоритма хеширования. Если пытаться получить доступ по ключу, которого не существует, Python выдаст ошибку KeyError. Однако, часто бывает полезно попытаться достать значение по ключу из словаря, а в случае отсутствия ключа вернуть какое-то стандартное значение. Для этого есть встроенный метод get. 

```python
print(collections_map['immutable']) 
print(collections_map['irresistible'])  # исключение
```
Проверка на вхождения ключа в словарь так же осуществляется за константное время и выполняется с помощью ключевого слова in: 

```python
'mutable' in collections_map 
```
Так как словарь является изменяемой структурой данных, мы можем добавлять и удалять элементы из него. Например, мы можем определить словарь beatles_map, который содержит знаменитых музыкантов и их инструменты, и добавить в него Ринго с ударными, просто используя доступ по ключу. Чтобы удалить ключ и значение из словаря, можно использовать уже знакомый вам оператор del. 

```python
beatles_map = { 
    'Paul': 'Bass', 
    'John': 'Guitar', 
    'George': 'Guitar', 
}
print(beatles_map) 
beatles_map['Ringo'] = 'Drums' 
print(beatles_map) 
del beatles_map['John']
print(beatles_map) 
```
Также, чтобы добавить какой-то ключ-значение в словарь, можно использовать встроенный метод update, который принимает словарь и дополняет им (а также обновляет в случае одинаковых ключей) исходный словарь. 

```python
beatles_map.update({ 
'John': 'Guitar' 
}) 
print(beatles_map)
```
Чтобы удалить ключ-значение из словаря и одновременно вернуть значение, используют метод pop: 

```python
# удаляем Ринго, нам возвращаются его ударные 
print(beatles_map.pop('Ringo')) 
print(beatles_map) 
```
Часто бывает необходимо не только попробовать проверить, существует ли ключ в словаре, но и в случае неудачи добавить эту новую пару ключ-значение. Для этого есть метод setdefault: 

```python
unknown_dict = {} 
print(unknown_dict.setdefault('key', 'default')) 
print(unknown_dict) 
```
Если вызвать setdefault и в качестве дефолтного значения передать new_default, вернётся значение, которое уже лежит в словаре - значение default: 

```python
print(unknown_dict.setdefault('key', 'new_default'))
```
Словари, как и все коллекции, поддерживают протокол итерации. С помощью цикла for можно итерироваться по ключам словаря: 

```python
print(collections_map) 
for key in collections_map: 
    print(key) 
```
Если нам нужно итерироваться не по ключам, а по ключам и значениям сразу, можно использовать метод словаря items, который возвращает ключи и значения. 

```python
for key, value in collections_map.items(): 
	print('{0} — {1}'.format(key, value)) 
```
Если нужно итерироваться по значениям, используйте логично метод values, который возвращает именно значения. Также существует симметричный метод keys, который возвращает итератор ключей. 

```python
for value in collections_map.values(): 
    print(value) 
```
Важная особенность словарей в Python: они содержат ключи и значения в неупорядоченном виде. Однако, в Python существует тип OrderedDict ( содержится в модуле collections), который гарантирует вам, что ключи хранятся именно в том порядке, в каком вы их добавили в словарь. **Замечание**. В python3.7 велись обсуждение, чтобы по умолчанию словарь был сортированным. Но в целом не стоит на это полагаться, в разных языках или даже разных версиях одного языка может быть по разному. Всегда предполагайте, что обычный словарь не упорядочен.

```python
from collections import OrderedDict 
ordered = OrderedDict() 
for number in range(10): 
    ordered[number] = str(number) 
for key in ordered: 
    print(key)
```
### Словари. Пример программы 
Разберём следующую задачу на словари: найти 3 самых часто встречающихся слова в Zen of Python. 
```python
import this 
```
Скопируем этот текст и поместим его в переменную zen. После этого заведём переменную zen_map, в которой будем хранить слова, которые уже нашли, и то, сколько раз их уже нашли. Будем итерироваться с помошью метода split(), который разобьёт нашу строку по пробельным символам. Очищать слова от знаков препинания и пробельных символов будем с помощью метода strip().

```python
zen_map = dict() 
for word in zen.split(): 
cleaned_word = word.strip('.,!-*').lower() 
# добавляем слово, если его ещё нет в zen_map: 
if cleaned_word not in zen_map: 
    zen_map[cleaned_word] = 0 
    zen_map[cleaned_word] += 1 
print(zen_map) 
```
На выходе имеем словарь, в котором ключами являются слова, а значениями - сколько раз слова встретились в тексте. Теперь найдём самые частотные слова. В переменную zen_items поместим список кортежей (ключ, значение) с помощью метода items(). Затем отсортируем список по вторым элементам в кортеже, используя модуль operator. В метод sorted() в качестве аргумента key передадим operator.itemgetter(1) (т.к. мы сортируем по элементам с индексом 1). 

```python
import operator 
zen_items = zen_map.items() 
word_count_items = sorted( 
    zen_items, key=operator.itemgetter(1), reverse=True 
)
print(word_count_items[:3])
```
Как это часто бывает в Python, существует встроенный модуль, который поможет вам решить эту задачу намного быстрее. Импортируем Counter из модуля collections. Теперь осталось только "очистить" слова и передать их в Counter. 

```python
from collections import Counter 
cleaned_list = [] 
for word in zen.split(): 
    cleaned_list.append(word.strip('.,-!').lower()) 
print(Counter(cleaned_list).most_common(3))
```
### Множества
Множество в питоне — это неупорядоченный набор уникальных объектов. Множества изменяемы и чаще всего используются для удаления дубликатов и всевозможных проверок на вхождение. Чтобы объявить пустое множество, можно воспользоваться литералом set или использовать фигурные скобки, чтобы объявить множество и одновременно добавить туда какие-то элементы. 

```python
empty_set = set() 
number_set = {1, 2, 3, 3, 4, 5} 
print(number_set)
```
Чтобы проверить, содержится ли объект в множестве, используется уже знакомое нам ключевое слово in. Проверка выполняется за константное время, время выполнения операции не зависит от размера множества. Это достигается за счёт хэширования каждого элемента структуры по аналогии со словарями. По полученному от хэш-функции ключу и происходит поиск объекта. Таким образом, во множествах могут содержаться только хэшируемые объекты. 

```python
print(2 in number_set)
```
Чтобы добавить элемент в множество, используется метод add. Также множества в Python поддерживают стандартные операции над множествами - такие как объединение, разность, пересечение и симметрическая разность. Создадим два множества с чётными и нечётными числами до десяти: 

```python
odd_set = set() 
even_set = set() 
for number in range(10): 
    if number % 2: 
        odd_set.add(number) 
    else:
        even_set.add(number) 
print(odd_set) 
print(even_set) 
```
Теперь найдём объединение и пересечение этих множеств: 

```python
union_set = odd_set | even_set 
union_set = odd_set.union(even_set) 
print(union_set) 

intersection_set = odd_set & even_set 
intersection_set = odd_set.intersection(even_set) 
print(intersection_set) 
```
Найдём разность двух множеств: 

```python
difference_set = odd_set - even_set 
difference_set = odd_set.difference(even_set) 
print(difference_set)
```
Или симметрическую разность: 

```python
symmetric_difference_set = odd_set ^ even_set 
symmetric_difference_set = odd_set.symmetric_difference(even_set) 
print(symmetric_difference_set) 
```
Множества - изменяемая структура данных, поэтому можно как добавлять туда элементы, так и удалять. Для удаления конкретного элемента существует метод remove, для удаления любого элемента можно использовать pop. Остальные методы можно посмотреть в help или документации. 

```python
even_set.remove(2) 
print(even_set) 
even_set.pop() 
```
Также в питоне существует неизменяемый аналог типа set - тип frozenset. 

```python
frozen = frozenset(['Anna', 'Elsa', 'Kristoff']) 
frozen.add('Olaf')  # порождает исключение AttributeError
```
### Множества. Пример программы 
**Задача на множества**: через сколько итераций функция random.randint(1, 10) выдаст повтор? 

Будем добавлять неповторяющиеся случайные числа в множество random\_set. Если очередное число уже есть в random_set - выйдем из цикла. Затем посчитаем длину множества (и прибавим 1, т.к. не учли последнее число). 

```python
import random 
random_set = set() 
while True: 
    new_number = random.randint(1, 10) 
    if new_number in random_set: 
        break 
    random_set.add(new_number) 
print(len(random_set) + 1) 
```
### Функции
Функция - это блок кода, который можно переиспользовать несколько раз в разных местах программы. Мы можем передавать функции аргументы и получать возвращаемые значения. Чтобы определить функцию в языке Python, нужно использовать литерал def и с помощью отступа определить блок кода функции. По PEP8 функции называют snake\_case-ом. После объявления функции в тройных двойных кавычках задаётся описание функции, так называемый docstring. Из него автоматически формируется документация по модулю.

Объявим функцию, которая возвращает секундную часть текущего времени. 


```python
from datetime import datetime 
def get_seconds(): 
    """Return current seconds""" 
    return datetime.now().second 

get_seconds() 
```
Чтобы получить документационную строку, можно обратиться к атрибуту doc, а имя функции получается с помощью атрибута name. Остальные аттрибуты посмотрите с помощью dir.

```python
get_seconds.__doc__
get_seconds.__name__ 
```
Чаще всего функция определяется с параметрами, т.к. зачастую функции каким-то образом обрабатывают переданные им значения. Определим функцию split\_tags, которая принимает параметр tag_string (например, равный строке с тегами текущего курса). 

Пусть функция разобьёт эту строку по запятым и вернёт список тегов. 

```python
def split_tags(tag_string): 
    tag_list = [] 
    for tag in tag_string.split(','): 
        tag_list.append(tag.strip()) 
    return tag_list 

split_tags('python, coursera, mooc') 
```
При вызове этой же функции без параметров получаем ошибку, т.к. функция ожидает заявленный параметр и не может работать без него.

```python
split_tags()  # порождает исключение TypeError
```
Выше мы не указывали явно, какого типа параметры функция ожидает, потому что Python - это язык с динамической типизацией. Но, например, в языке C типы аннотируются, т.е. явно указывается, какого типа должен быть параметр функции и какого типа возвращаемые значения. В Python-е последних версий появилась возможность аннотировать типы, и делается это с помощью двоеточия в случае параметров, а стрелочкой указывают тип возвращаемого значения. Однако, если мы передадим в функцию параметры других типов, код все равно выполнится, потому что Python - это динамический язык, и аннотация типов призвана лишь помочь программисту или его IDE отловить какие-то ошибки. 

```python
def add(x: int, y: int) -> int: 
    return x + y 

print(add(10, 11)) 
print(add('still ', 'works'))  # работает, т.к. + для строк перегружен как конкатенация
print(add('do not work', 123)  # порождает исключение TypeError, т.к. операция строка+число не определена
```
Во многих других языках программирования значения параметра передаются в функцию либо по ссылке, либо по значению (и между двумя этими случаями проводится строгая граница). В Python каждая переменная является связью имени с объектом в памяти, и именно эта ссылка на объект передается в функцию. Таким образом, если мы передадим в функцию список и в ходе выполнения функции изменим его, этот список измениться глобально: 

```python
def extender(source_list, extend_list): 
    source_list.extend(extend_list) 

values = [1, 2, 3] 
extender(values, [4, 5, 6]) 
print(values) 
```
Если мы так же попытаемся изменить объект неизменяего типа, он, что логично, не изменится (мы передаем ссылку на объект в памяти, который неизменяем). 

```python
def replacer(source_tuple, replace_with): 
	source_tuple = replace_with 
	
user_info = ('Guido', '31/01') 
replacer(user_info, ('Larry', '27/09')) 
print(user_info) 
```
Однако изменение глобальных переменных внутри функции является плохим тоном, потому что часто бывает не очевидно, какие глобальные объекты как изменяются в каких функциях. В таких ситуациях советуют использовать возвращаемые значения. 

В Python также существуют именованные аргументы, которые иногда бывают полезны. Если явно указывать имена аргументов, можно передавать их в любом порядке. Кроме того, при вызове функции будет видно, каким аргументам мы присваиваем передаваемые значения. 

```python
def say(greeting, name): 
    print('{} {}!'.format(greeting, name)) 

say('Hello', 'Kitty') 
say(name='Kitty', greeting='Hello')
```
Важно понимать, что переменные, объявленные вне области видимости функции, нельзя изменять. 

```python
result = 0 
def increment(): 
    result += 1 
    return result 

print(increment())  # порождается исключение UnboundLocalError
```
В Python всё же есть возможность изменять глобальные переменные с помощью global или non local, но использовать эти особенности не рекомендуется.

Существует также возможность использовать аргументы по умолчанию, которые можно передавать, а можно не передавать. У этих аргументов, могут быть определены какие-то дефолтные значения, которые прописываются при объявлении функции: 

```python
def greeting(name='it\'s me...'): 
    print('Hello, {}'.format(name)) 

greeting() 
```
Стоит быть внимательными с аргументами по умолчанию, если мы используем в качестве их дефолтного значения объекты изменяемого типа. Например, объявим функцию, которая прибавляет к списку элемент 1. В качестве значения по умолчанию зададим пустой список: 

```python
def append_one(iterable=[]): 
    iterable.append(1) 
    return iterable 

print(append_one([1])) 
```
Что произойдёт, если мы вызовем эту функцию дважды: 

```python
print(append_one()) 
print(append_one()) 
```
Чтобы разобраться, проверим, каковы дефолтные значения параметров функции: 

```python
print(append_one.__defaults__) 
```
Почему так происходит? При определении функции, когда интерпретатор Python проходит по файлу с кодом, определяется связь между именем функции и дефолтными значениями. Таким образом, у каждой функции появляется tuple с дефолтными значениями. Именно в эти переменные каждый раз и происходит запись. Таким образом, если дефолтные значения являются изменяемыми, в них можно записывать, потому что это обычные переменные. 

Чтобы исправить предыдущий пример, возьмём в качестве значения по умолчанию None одним из следующих способов: 

```python
def function(iterable=None): 
    if iterable is None: 
        iterable = [] 
    return iterable

def function(iterable=None): 
    iterable = iterable or []  # это важная идиома. Если iterable == None, в будет использовано []
    return iterable
```
Довольно красивой особенностью Python является возможность определения функции, которая принимает разные количества аргументов. Определим функцию printer, которая принимает любое количество аргументов - все аргументы записываются в tuple args. Затем функция печатает по порядку все аргументы: 

```python
def printer(*args): 
    print(type(args)) 

    for argument in args: 
        print(argument) 

printer(1, 2, 3, 4, 5) 
```
Также в аргументах можно развернуть список значений: 

```python
name_list = ['John', 'Bill', 'Amy'] 
printer(*name_list) 
```
Точно так же это работает в случае со словарями, в данном случае мы можем определить функцию printer, которая принимает разное количество именованных аргументов. При этом переменная kwargs будет иметь тип dict. 

```python
def printer(**kwargs): 
    print(type(kwargs)) 

    for key, value in kwargs.items(): 
        print('{}: {}'.format(key, value)) 

printer(a=10, b=11) 
```
Точно так же мы можем разыменовывать (разворачивать) словари, используя **: 

```python
payload = { 
    'user_id': 117, 
    'feedback': { 
        'subject': 'Registration fields', 
        'message': 'There is no country for old men' 
    } 
}

printer(**payload) 
```
Это используется практически везде и позволяет вам определять очень гибкие функции, которые принимают различное количество аргументов — именованных и позиционных. 

```python

```

### Самостоятельная работа
1. Доработка программы из ПЗ2. Заменить множественные if на вызов функции из словаря. В dict вида {'func\_name': function} помещаете все реализованные. Ввод пользователя превращаете в строку вида 'func\_name', после чего выполняете конструкцию вида client\_handler = COMMANDS.get(cmd, cmd\_default). Полученный client\_handler используете для вызова нужной функции.

2. Реализовать меню вида "1. угадайка". Допускать ввод соответствующей цифры вместе с возможностью ввода названий подпрограмм. То есть ввод "1" или "угадайка" должен приводить к запуску соответствующей программы.

3. Проверка кода возврата - реализовать так, что exit выходит из подпрограммы и завершает основную программу с сообщением "завершена подпрограмма Х", где Х - это угадайка, калькулятор или покричи. Ввод q в подпрограмме должен завершать подпрограмму и выводить меню из доступных подпрограмм.